/* Returns a list of die */
dice = {"⚀";"⚁";"⚂";"⚃";"⚄";"⚅"};

/* Gets the number of pips on a die */
pips = LAMBDA(d, UNICODE(d) - 9855);

/* Shortened LEN() - LEN(SUBSTITUTE()) and divides by length */
countOcc = LAMBDA(str, sub, (LEN(str) - LEN(SUBSTITUTE(str, sub, ""))) / LEN(sub));

/* Returns a split list of characters from a string */
ltrs = LAMBDA(wrd, [len], [split], LET(_len, MAX(len, 1), IF(split, MID(wrd, SEQUENCE(LEN(wrd)/_len,,1,_len), _len), MID(wrd, SEQUENCE(LEN(wrd)-_len+1), _len))));

/* Returns a list of arrows */
arrs = {"←","→","↑","↓","↖","↗","↙","↘"};

/* Returns -1 for arrow pointing left, 1 for right, and 0 for up or down */
arrsLR = {-1,1,0,0,-1,1,-1,1};

/* Returns 0 for arrow pointing left or right, -1 for down, and 1 for up */
arrsUD = {0,0,1,-1,1,1,-1,-1};

/* Stacks all 3 of the arrows functions */
arrsAll = VSTACK(arrs, arrsLR, arrsUD);

/* Arrow combinations: customizable with row/col multipliers */
arrsComb = LAMBDA([rwMult], [clMult], arrsLR * IF(ISOMITTED(clMult),1,clMult) + arrsUD * IF(ISOMITTED(rwMult),1000,rwMult));

/* Knight movement vectors */
knightLR = {1;1;-1;-1;2;2;-2;-2};
knightUD = {2;-2;2;-2;1;-1;1;-1};
knightComb = LAMBDA(Lrmult, UDmult, _knightLR * Lrmult + _knightUD * UDmult);

/* Combine directions */
dirsComb = LAMBDA(Lrshift, Lrmult, UDshift, UDmult, Lrshift * Lrmult + UDshift * UDmult);

/* Returns a list of card suits */
suits = {"♦";"♥";"♠";"♣"};

/* Returns the opposite card suit */
suitsOpp = {"♥";"♦";"♣";"♠"};

/* Can be used to return a list of cards with their number and suit */
cardOrd = {"A";"2";"3";"4";"5";"6";"7";"8";"9";"1";"J";"Q";"K"};

/* Gets the most frequent items in a range */
mostOf = LAMBDA(rng, [ord], [only], LET(
  a, UNIQUE(TOCOL(rng, 3)),
  b, MAP(a, LAMBDA(x, SUM(--(IFERROR(x = rng, 0))))),
  sorted, SORT(HSTACK(a, b), 2, IF(ISOMITTED(ord), -1, ord)),
  IF(only, INDEX(sorted, 1, 2), sorted)
));

/* Returns the character that comes after in a list */
nxt = LAMBDA(arr, [n], [fill], LET(
  _n, MAX(1, n),
  _fill, IF(ISOMITTED(fill), "X", fill),
  IF(ROWS(arr) = 1,
     HSTACK(DROP(arr,,_n), IF(SEQUENCE(,_n), _fill)),
     VSTACK(DROP(arr,_n), IF(SEQUENCE(_n, COLUMNS(arr)), _fill))
  )
));

/* Returns the previous character in a list */
prev = LAMBDA(arr, [n], [fill], LET(
  _n, MAX(1, n),
  _fill, IF(ISOMITTED(fill), "X", fill),
  IF(ROWS(arr) = 1,
     HSTACK(IF(SEQUENCE(,_n), _fill), DROP(arr,,-_n)),
     VSTACK(IF(SEQUENCE(_n, COLUMNS(arr)), _fill), DROP(arr,-_n))
  )
));

/* Gives all the possible combinations of numbers (only handles single digits) */
perCom = LAMBDA(n, c, [P0C1], [rep], LET(
  s, SEQUENCE(,n),
  --MID(REDUCE("", SEQUENCE(c), LAMBDA(a,w,
    TOCOL(IFS(
      IF(P0C1, IF(rep, RIGHT(a)<=s&"", RIGHT(a)<s&""),
      IF(rep, 1, ISERR(FIND(s, a)))
    ), a&s), 3))),
  SEQUENCE(,c), 1)
));

/* Gives the relative addresses of a range */
addresses = LAMBDA(rng, ADDRESS(ROW(rng), COLUMN(rng), 4));

/* Gets the address in steps of 1000 */
rwClNm = LAMBDA(arr, [rwMult], [clMult],
  IF(ISOMITTED(rwMult), 1000, rwMult) * SEQUENCE(ROWS(arr)) +
  IF(ISOMITTED(clMult), 1, clMult) * SEQUENCE(, COLUMNS(arr))
);

/* Gives the distance from a target in a grid */
distFrom = LAMBDA(mp, trg, func, LET(
  vals, TOCOL(mp),
  rws, TOCOL(SEQUENCE(ROWS(mp)) + 0*SEQUENCE(,COLUMNS(mp))),
  cls, TOCOL(SEQUENCE(ROWS(mp))*0 + SEQUENCE(,COLUMNS(mp))),
  Mrws, TOROW(FILTER(rws, vals = trg)),
  Mcls, TOROW(FILTER(cls, vals = trg)),
  rdist, ABS(rws - Mrws),
  cdist, ABS(cls - Mcls),
  dist, BYROW(MAP(rdist, cdist, func), MIN),
  WRAPROWS(dist, COLUMNS(mp))
));

/* Applies a function to a cell's neighbors in a range */
neighborOp = LAMBDA(rng, dist, fnc, MAKEARRAY(
  ROWS(rng), COLUMNS(rng),
  LAMBDA(r, c,
    fnc(LET(
      firstRw, MAX(r - dist, 1),
      firstCl, MAX(c - dist, 1),
      lastRw, MIN(r + dist, ROWS(rng)),
      lastCl, MIN(c + dist, COLUMNS(rng)),
      CHOOSECOLS(
        CHOOSEROWS(rng, SEQUENCE(lastRw - firstRw + 1,,firstRw)),
        SEQUENCE(lastCl - firstCl + 1,,firstCl)
      )
    ))
  )
));
/* Checks whether a palindrome is given (answer with TRUE/FALSE) */
isPalindrome = LAMBDA(text,
    LET(
        clean, LOWER(SUBSTITUTE(SUBSTITUTE(TRIM(text), " ", ""), "-", "")),
        clean = TEXTJOIN("", , MID(clean, SEQUENCE(LEN(clean),,LEN(clean),-1), 1))
    )
);
/* Reverses a string */
reverseString = LAMBDA(txt,
    TEXTJOIN("",,MID(txt,SEQUENCE(LEN(txt),,LEN(txt),-1),1))
);
/* Extracts numbers from a string */
extractNumbers = LAMBDA(txt,
    TEXTJOIN("",,
        IFERROR(
            MID(txt, SEQUENCE(LEN(txt)), 1) * 1,
            ""
        )
    )
);
notInText = LAMBDA(TextOrRange, CaseSensitive, Mode,
  LET(
    txt, TEXTJOIN("",,TextOrRange),
    n, LEN(txt),

    /* source sets */
    upper, "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    lower, "abcdefghijklmnopqrstuvwxyz",
    digits, "0123456789",

    /* arrays of single characters */
    txtArr, IF(n, MID(txt, SEQUENCE(n), 1), ""),
    txtArrUpper, IF(n, MID(UPPER(txt), SEQUENCE(n), 1), ""),
    upperArr, MID(upper, SEQUENCE(LEN(upper)), 1),
    lowerArr, MID(lower, SEQUENCE(LEN(lower)), 1),
    digitsArr, MID(digits, SEQUENCE(LEN(digits)), 1),

    /* missing numbers (simple, case irrelevant) */
    missingNumbers, IFERROR(TEXTJOIN("",,FILTER(digitsArr, ISNA(MATCH(digitsArr, txtArr, 0)))), ""),

    /* case-insensitive letters missing (Mode=0, CaseSensitive=0) */
    missingCI, IFERROR(TEXTJOIN("",,FILTER(upperArr, ISNA(MATCH(upperArr, txtArrUpper, 0)))), ""),

    /* case-sensitive presence checks using EXACT() -> then build missing U/L */
    presentUpper_CS, MAP(upperArr, LAMBDA(ch, SUM(--EXACT(ch, txtArr))>0)),
    presentLower_CS, MAP(lowerArr, LAMBDA(ch, SUM(--EXACT(ch, txtArr))>0)),
    missingUpper, IFERROR(TEXTJOIN("",,FILTER(upperArr, NOT(presentUpper_CS))), ""),
    missingLower, IFERROR(TEXTJOIN("",,FILTER(lowerArr, NOT(presentLower_CS))), ""),

    /* final result routing */
    IF(Mode=1,
       missingNumbers,
       IF(CaseSensitive=1,
          VSTACK(missingUpper, missingLower),
          missingCI
       )
    )
  )
);
missingNumbers = LAMBDA(InputArray, MaxNum,
  LET(
    fullSet, SEQUENCE(MaxNum),                           /* full list from 1 to MaxNum */
    missing, FILTER(fullSet, ISNA(MATCH(fullSet, InputArray, 0))),
    missing
  )
)
